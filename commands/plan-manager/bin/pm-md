#!/usr/bin/env bash
# pm-md ‚Äî Markdown operations for plan-manager
# Usage: pm-md <subcommand> [options]

set -euo pipefail
source "$(dirname "${BASH_SOURCE[0]}")/helpers.sh"

SUBCOMMAND="${1:-}"
shift 2>/dev/null || true

usage() {
  cat >&2 <<'EOF'
Usage: pm-md <subcommand> [options]

Subcommands:
  extract-phases --file P
      Extract phase headings ‚Üí JSON array [{phase, title, icon}]
  extract-dashboard --file P
      Parse Status Dashboard table ‚Üí JSON array of rows
  add-dashboard --file P
      Insert Status Dashboard section into master plan (idempotent)
  update-phase-icon --file P --phase N --icon ICON
      Replace phase header icon in heading + dashboard
  update-dashboard-row --file P --phase N [--status S] [--subplan-link L]
      Update specific dashboard row cells
  add-parent-header --file P --type T --parent P --phase N [--pre-planned bool] [--date D]
      Prepend Type/Parent/Created/Status/BlockedBy block
  update-links --file P --old L --new L
      Replace all occurrences of a link/path in file
  update-blockedby --file P --value V
      Set **BlockedBy:** field value
  anchor --text T
      Convert heading text ‚Üí GitHub anchor string ‚Üí stdout
  classify --file P
      Detect type (master/sub-plan/branch/standalone) and category ‚Üí JSON
  detect-random-name --filename F
      Check if filename matches random pattern ‚Üí JSON {random: bool}
EOF
  exit 1
}

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

require_file() {
  local file="$1"
  local root
  root="$(project_root)"
  local abs="$root/$file"
  [ -f "$abs" ] || die "File not found: $file"
  echo "$abs"
}

# Convert a heading text to a GitHub-style anchor
text_to_anchor() {
  local text="$1"
  # Lowercase, keep letters/digits/spaces/hyphens, replace spaces with hyphens
  # Strip leading emoji/icon characters (non-ASCII)
  echo "$text" \
    | LC_ALL=C sed 's/[^a-zA-Z0-9 -]//g' \
    | tr '[:upper:]' '[:lower:]' \
    | sed 's/ \+/-/g' \
    | sed 's/^-\+//' \
    | sed 's/-\+$//'
}

# Get icon for a status string
status_to_icon() {
  case "$1" in
    pending)     echo "‚è≥" ;;
    in_progress) echo "üîÑ" ;;
    blocked)     echo "‚è∏Ô∏è" ;;
    complete|completed) echo "‚úÖ" ;;
    sub-plan)    echo "üìã" ;;
    branch)      echo "üîÄ" ;;
    *)           echo "‚è≥" ;;
  esac
}

# ---------------------------------------------------------------------------
# extract-phases
# ---------------------------------------------------------------------------
cmd_extract_phases() {
  local file=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file) file="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ] && die "--file is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Match lines like: ## [optional-icon] Phase N: Title
  # or: ## [optional-icon] Step N: Title
  local result="[]"
  while IFS= read -r line; do
    # Match Phase/Step headings at level 2
    if [[ "$line" =~ ^##[[:space:]] ]]; then
      local content="${line#\#\# }"
      # Try to match: [icon] Phase N: Title or Phase N: Title
      if [[ "$content" =~ ^([^P]*)([Pp]hase|[Ss]tep)[[:space:]]+([0-9]+(\.[0-9]+)?):(.*)$ ]]; then
        local icon="${BASH_REMATCH[1]}"
        local phase_num="${BASH_REMATCH[3]}"
        local title="${BASH_REMATCH[5]}"
        # Trim whitespace
        icon="$(echo "$icon" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        title="$(echo "$title" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        result="$(echo "$result" | jq \
          --arg num "$phase_num" \
          --arg title "$title" \
          --arg icon "$icon" \
          '. + [{"phase": ($num | tonumber), "title": $title, "icon": $icon}]')"
      fi
    fi
  done < "$abs_file"

  echo "$result"
}

# ---------------------------------------------------------------------------
# extract-dashboard
# ---------------------------------------------------------------------------
cmd_extract_dashboard() {
  local file=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file) file="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ] && die "--file is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Find Status Dashboard section and parse its table
  local in_dashboard=false
  local in_table=false
  local result="[]"
  local row_num=0

  while IFS= read -r line; do
    if [[ "$line" =~ ^##[[:space:]]Status[[:space:]]Dashboard ]]; then
      in_dashboard=true
      continue
    fi

    if [ "$in_dashboard" = true ]; then
      # Stop at next ## heading
      if [[ "$line" =~ ^##[[:space:]] ]] && ! [[ "$line" =~ ^##[[:space:]]Status[[:space:]]Dashboard ]]; then
        break
      fi

      # Detect table rows (pipe-delimited)
      if [[ "$line" =~ ^\| ]]; then
        # Skip separator row
        [[ "$line" =~ ^\|[-|[:space:]]+\|$ ]] && continue
        [[ "$line" =~ ^\|[[:space:]]*[-]+[[:space:]]*\| ]] && continue

        row_num=$((row_num + 1))
        [ "$row_num" -eq 1 ] && continue  # Skip header row

        # Parse cells: | Phase | Description | Status | Sub-plan |
        local cells=()
        IFS='|' read -ra raw_cells <<< "$line"
        for cell in "${raw_cells[@]}"; do
          cell="$(echo "$cell" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
          cells+=("$cell")
        done

        # cells[0] is empty (before first |), cells[1..4] are our columns
        local phase_cell="${cells[1]:-}"
        local desc_cell="${cells[2]:-}"
        local status_cell="${cells[3]:-}"
        local subplan_cell="${cells[4]:-}"

        result="$(echo "$result" | jq \
          --arg phase "$phase_cell" \
          --arg desc "$desc_cell" \
          --arg status "$status_cell" \
          --arg subplan "$subplan_cell" \
          '. + [{"phase": $phase, "description": $desc, "status": $status, "subplan": $subplan}]')"
      fi
    fi
  done < "$abs_file"

  echo "$result"
}

# ---------------------------------------------------------------------------
# add-dashboard
# Insert Status Dashboard section into master plan (idempotent)
# ---------------------------------------------------------------------------
cmd_add_dashboard() {
  local file=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file) file="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ] && die "--file is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Check if dashboard already exists
  if grep -q "^## Status Dashboard" "$abs_file"; then
    echo '{"success":true,"added":false,"reason":"Dashboard already exists"}'
    return 0
  fi

  # Extract phases from file
  local phases_json
  phases_json="$(cmd_extract_phases --file "$file")"
  local phase_count
  phase_count="$(echo "$phases_json" | jq 'length')"

  if [ "$phase_count" -eq 0 ]; then
    die "No phases found in $file ‚Äî cannot add Status Dashboard"
  fi

  # Build dashboard table
  local dashboard
  dashboard=$'## Status Dashboard\n\n| Phase | Description | Status | Sub-plan |\n|-------|-------------|--------|----------|\n'

  # Add icon to phase headings first, then build dashboard
  for i in $(seq 0 $((phase_count - 1))); do
    local phase_num
    phase_num="$(echo "$phases_json" | jq -r ".[$i].phase")"
    local title
    title="$(echo "$phases_json" | jq -r ".[$i].title")"
    local icon
    icon="$(echo "$phases_json" | jq -r ".[$i].icon")"

    # Add ‚è≥ icon to phase heading if no icon yet
    if [ -z "$icon" ]; then
      # Update heading in file
      local pattern="^## \(Phase\|Step\) ${phase_num}:"
      # Use sed to add ‚è≥ icon
      local escaped_num="$phase_num"
      # Replace "## Phase N:" with "## ‚è≥ Phase N:"
      sed -i.bak -E "s|^(## )(Phase|Step) (${escaped_num}:)|\1‚è≥ \2 \3|" "$abs_file"
      rm -f "${abs_file}.bak"
      icon="‚è≥"
    fi

    # Build anchor: icon + "Phase N: Title" ‚Üí anchor
    local heading_text="$icon Phase ${phase_num}: $title"
    # For anchor: strip non-alphanumeric (keep spaces/hyphens), lowercase, spaces‚Üíhyphens
    local anchor
    anchor="$(text_to_anchor "$heading_text")"

    local phase_int
    phase_int="$(echo "$phase_num" | cut -d. -f1)"
    dashboard+="| ${phase_int} | [${title}](#${anchor}) | ‚è≥ Pending | ‚Äî |"$'\n'
  done

  # Insert dashboard after the first h1 heading (or at top of file after metadata)
  # Strategy: insert after first blank line following the h1
  local tmp_file
  tmp_file="$(mktemp)"
  local inserted=false
  local after_h1=false

  while IFS= read -r line; do
    echo "$line" >> "$tmp_file"
    if [ "$inserted" = false ]; then
      if [[ "$line" =~ ^#[[:space:]] ]]; then
        after_h1=true
      elif [ "$after_h1" = true ] && [ -z "$line" ]; then
        echo "" >> "$tmp_file"
        echo "$dashboard" >> "$tmp_file"
        inserted=true
      fi
    fi
  done < "$abs_file"

  if [ "$inserted" = false ]; then
    # Fallback: insert at beginning of file
    { echo "$dashboard"; echo ""; cat "$abs_file"; } > "$tmp_file"
  fi

  mv "$tmp_file" "$abs_file"
  echo '{"success":true,"added":true}'
}

# ---------------------------------------------------------------------------
# update-phase-icon
# ---------------------------------------------------------------------------
cmd_update_phase_icon() {
  local file="" phase="" icon=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file)  file="$2";  shift 2 ;;
      --phase) phase="$2"; shift 2 ;;
      --icon)  icon="$2";  shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ]  && die "--file is required"
  [ -z "$phase" ] && die "--phase is required"
  [ -z "$icon" ]  && die "--icon is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Update heading: replace existing icon (any non-alnum before Phase/Step) or add new one
  # Pattern: ## [anything] Phase N: Title ‚Üí ## ICON Phase N: Title
  sed -i.bak -E "s|^(## )[^P]*(Phase|Step) (${phase}:)|\1${icon} \2 \3|" "$abs_file"
  rm -f "${abs_file}.bak"

  # Update dashboard row status icon (first column icon area kept as-is, update Status cell)
  # The dashboard row for phase N looks like: | N | [desc](anchor) | ICON Status | subplan |
  # We update the Description column anchor to match the new heading
  # Note: Dashboard icon update is done via update-dashboard-row

  echo '{"success":true}'
}

# ---------------------------------------------------------------------------
# update-dashboard-row
# ---------------------------------------------------------------------------
cmd_update_dashboard_row() {
  local file="" phase="" new_status="" subplan_link=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file)         file="$2";         shift 2 ;;
      --phase)        phase="$2";        shift 2 ;;
      --status)       new_status="$2";   shift 2 ;;
      --subplan-link) subplan_link="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ]  && die "--file is required"
  [ -z "$phase" ] && die "--phase is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Phase number as integer (for matching first column)
  local phase_int
  phase_int="$(echo "$phase" | cut -d. -f1)"

  # We need to update the row matching "| N |" in the Status Dashboard
  # Use awk to find and update the row
  local tmp_file
  tmp_file="$(mktemp)"

  awk -v phase="$phase_int" \
      -v new_status="$new_status" \
      -v subplan_link="$subplan_link" \
      '
  BEGIN { in_dashboard = 0 }
  /^## Status Dashboard/ { in_dashboard = 1 }
  /^## / && !/^## Status Dashboard/ { if (in_dashboard) in_dashboard = 0 }
  {
    if (in_dashboard && /^\| *[0-9]/) {
      # Split by pipe
      n = split($0, cells, "|")
      # cells[2] = phase number (trimmed)
      ph = cells[2]
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", ph)
      if (ph == phase) {
        # Update status if provided
        if (new_status != "") {
          cells[4] = " " new_status " "
        }
        # Update subplan link if provided
        if (subplan_link != "") {
          cells[5] = " " subplan_link " "
        }
        # Reconstruct row
        row = ""
        for (i = 1; i <= n; i++) {
          row = row "|" cells[i]
        }
        print row
        next
      }
    }
    print
  }
  ' "$abs_file" > "$tmp_file"

  mv "$tmp_file" "$abs_file"
  echo '{"success":true}'
}

# ---------------------------------------------------------------------------
# add-parent-header
# Prepend Type/Parent/Created/Status/BlockedBy block to a file
# ---------------------------------------------------------------------------
cmd_add_parent_header() {
  local file="" type="" parent="" phase="" pre_planned="false" date=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file)        file="$2";        shift 2 ;;
      --type)        type="$2";        shift 2 ;;
      --parent)      parent="$2";      shift 2 ;;
      --phase)       phase="$2";       shift 2 ;;
      --pre-planned) pre_planned="$2"; shift 2 ;;
      --date)        date="$2";        shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ]   && die "--file is required"
  [ -z "$type" ]   && die "--type is required"
  [ -z "$parent" ] && die "--parent is required"
  [ -z "$phase" ]  && die "--phase is required"

  [ -z "$date" ] && date="$(today_iso)"

  local abs_file
  abs_file="$(require_file "$file")"

  # Check if header already exists
  if grep -q "^\*\*Type:\*\*" "$abs_file"; then
    echo '{"success":true,"added":false,"reason":"Parent header already exists"}'
    return 0
  fi

  # Build header block
  local header=""
  local date_label="Created"

  if [ "$type" = "Sub-plan" ]; then
    header="**Type:** Sub-plan  <br>
**Parent:** ${parent} ‚Üí Phase ${phase}  <br>
**${date_label}:** ${date}  <br>
**Pre-planned:** $([ "$pre_planned" = "true" ] && echo "Yes" || echo "No")  <br>
**Status:** In Progress  <br>
**BlockedBy:** ‚Äî

---

"
  else
    # Branch
    header="**Type:** Branch  <br>
**Parent:** ${parent} ‚Üí Phase ${phase}  <br>
**${date_label}:** ${date}  <br>
**Status:** In Progress  <br>
**BlockedBy:** ‚Äî

---

"
  fi

  # Prepend header after the first h1 heading
  local tmp_file
  tmp_file="$(mktemp)"
  local inserted=false
  local past_h1=false

  while IFS= read -r line; do
    if [ "$inserted" = false ]; then
      if [ "$past_h1" = false ] && [[ "$line" =~ ^#[[:space:]] ]]; then
        echo "$line" >> "$tmp_file"
        past_h1=true
        continue
      elif [ "$past_h1" = true ]; then
        echo "" >> "$tmp_file"
        printf '%s' "$header" >> "$tmp_file"
        inserted=true
      fi
    fi
    echo "$line" >> "$tmp_file"
  done < "$abs_file"

  if [ "$inserted" = false ]; then
    { printf '%s' "$header"; cat "$abs_file"; } > "$tmp_file"
  fi

  mv "$tmp_file" "$abs_file"
  echo '{"success":true,"added":true}'
}

# ---------------------------------------------------------------------------
# update-links
# Replace all occurrences of old link/path with new in file
# ---------------------------------------------------------------------------
cmd_update_links() {
  local file="" old_link="" new_link=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file) file="$2";     shift 2 ;;
      --old)  old_link="$2"; shift 2 ;;
      --new)  new_link="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ]     && die "--file is required"
  [ -z "$old_link" ] && die "--old is required"
  [ -z "$new_link" ] && die "--new is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Escape for sed
  local escaped_old
  escaped_old="$(printf '%s\n' "$old_link" | sed 's/[[\.*^$()+?{|]/\\&/g; s|/|\\/|g')"
  local escaped_new
  escaped_new="$(printf '%s\n' "$new_link" | sed 's/[[\.*^$()+?{|]/\\&/g; s|/|\\/|g')"

  sed -i.bak "s/${escaped_old}/${escaped_new}/g" "$abs_file"
  rm -f "${abs_file}.bak"

  echo '{"success":true}'
}

# ---------------------------------------------------------------------------
# update-blockedby
# ---------------------------------------------------------------------------
cmd_update_blockedby() {
  local file="" value=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file)  file="$2";  shift 2 ;;
      --value) value="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ]  && die "--file is required"
  [ -z "$value" ] && die "--value is required"

  local abs_file
  abs_file="$(require_file "$file")"

  # Replace **BlockedBy:** line
  local escaped_value
  escaped_value="$(printf '%s\n' "$value" | sed 's/[[\.*^$()+?{|]/\\&/g; s|/|\\/|g')"

  sed -i.bak "s|^\*\*BlockedBy:\*\*.*|**BlockedBy:** ${escaped_value}|" "$abs_file"
  rm -f "${abs_file}.bak"

  echo '{"success":true}'
}

# ---------------------------------------------------------------------------
# anchor
# ---------------------------------------------------------------------------
cmd_anchor() {
  local text=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --text) text="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$text" ] && die "--text is required"

  text_to_anchor "$text"
}

# ---------------------------------------------------------------------------
# classify
# Detect file type and category
# ---------------------------------------------------------------------------
cmd_classify() {
  local file=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --file) file="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$file" ] && die "--file is required"

  local abs_file
  abs_file="$(require_file "$file")"

  local content
  content="$(cat "$abs_file")"
  local lower_content
  lower_content="$(echo "$content" | tr '[:upper:]' '[:lower:]')"

  # Determine type
  local type="standalone"

  if echo "$content" | grep -q "^\*\*Type:\*\* Sub-plan"; then
    type="sub-plan"
  elif echo "$content" | grep -q "^\*\*Type:\*\* Branch"; then
    type="branch"
  elif echo "$content" | grep -qE "^## (‚è≥ |üîÑ |‚úÖ |‚è∏Ô∏è )?(Phase|Step) [0-9]"; then
    type="master"
  fi

  # Determine category (for standalone plans)
  local category="standalone"

  if echo "$lower_content" | grep -qE "(migrat|upgrade|transition|port )"; then
    category="migration"
  elif echo "$lower_content" | grep -qE "(documentation|guide|manual|how-to|reference|readme)"; then
    category="documentation"
  elif echo "$lower_content" | grep -qE "(design|architecture|proposal|rfc|spec)"; then
    category="design"
  elif echo "$lower_content" | grep -qE "(feature|enhancement|new feature|add support)"; then
    category="feature"
  elif echo "$lower_content" | grep -qE "(bug|fix|issue|problem|error|hotfix)"; then
    category="bugfix"
  fi

  echo "{\"type\":\"$type\",\"category\":\"$category\"}"
}

# ---------------------------------------------------------------------------
# detect-random-name
# ---------------------------------------------------------------------------
cmd_detect_random_name() {
  local filename=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --filename) filename="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done
  [ -z "$filename" ] && die "--filename is required"

  # Strip directory and extension
  local basename
  basename="$(basename "$filename" .md)"

  local is_random=false

  # Pattern: three-word-combo (adjective-adjective-noun style, no numbers, no tech roots)
  # e.g. lexical-puzzling-emerson, magical-moseying-swing, toasty-herding-gem
  # Exclude meaningful prefixes: my-, the-, new-, old-, phase[0-9], step[0-9], etc.
  if [[ "$basename" =~ ^[a-z]+-[a-z]+-[a-z]+$ ]]; then
    # Exclude names with common meaningful tech/project words as the first part
    local first_word="${basename%%-*}"
    case "$first_word" in
      my|the|new|old|phase*|step*|plan|draft|feature|bug|fix|api|ui|db|auth|test|dev|prod)
        is_random=false ;;
      *)
        is_random=true ;;
    esac
  fi

  # Generic names
  case "$basename" in
    plan-[0-9]*|new-plan|untitled|draft|temp|tmp|plan)
      is_random=true ;;
  esac

  # UUID pattern
  if [[ "$basename" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
    is_random=true
  fi

  echo "{\"random\":$is_random,\"filename\":\"$filename\"}"
}

# ---------------------------------------------------------------------------
# Dispatch
# ---------------------------------------------------------------------------
case "$SUBCOMMAND" in
  extract-phases)     cmd_extract_phases "$@" ;;
  extract-dashboard)  cmd_extract_dashboard "$@" ;;
  add-dashboard)      cmd_add_dashboard "$@" ;;
  update-phase-icon)  cmd_update_phase_icon "$@" ;;
  update-dashboard-row) cmd_update_dashboard_row "$@" ;;
  add-parent-header)  cmd_add_parent_header "$@" ;;
  update-links)       cmd_update_links "$@" ;;
  update-blockedby)   cmd_update_blockedby "$@" ;;
  anchor)             cmd_anchor "$@" ;;
  classify)           cmd_classify "$@" ;;
  detect-random-name) cmd_detect_random_name "$@" ;;
  ""|--help|-h)       usage ;;
  *) die "Unknown subcommand: $SUBCOMMAND. Run 'pm-md --help' for usage." ;;
esac
